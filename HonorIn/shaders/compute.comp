#version 450

//constants ========================================================= 
#define EPSILON 0.0001
#define MAXLEN 1000.0
//#define RAYBOUNCES 5//5
#define REFLECTIONS true

bool debugTest = false;

//Inside your compute shader, you define a workgroup size
layout (local_size_x = 16, local_size_y = 16) in;
//layout (local_size_x = 32, local_size_y = 32) in;

//This specifies how many threads are organized in each dimension within a workgroup. 
//The workgroup size determines the granularity of parallelism for your computation.

//Bindings ========================================================= 

layout (binding = 0, rgba8) uniform writeonly image2D resultImage;
//https://vulkan-tutorial.com/Uniform_buffers/Descriptor_pool_and_sets#page_Alignment-requirements
//https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout

//definition of structs that are in structs in the ubo
struct HyperSphere 
{
	vec4 pos;
	float radius;
	vec3 diffuse;
	float specular;
	float reflectionStrength;
	float reflectionFallOff; 
	int id;
	int status;
};

struct AABB
{
	vec4 pos; //center
	float xRadius;
	float yRadius;
	float zRadius;
	float wRadius;
	vec3 diffuse;
	float specular;
	float reflectionStrength; //default initialized at 0.6
	float reflectionFallOff; //default initialized at 0.6 //if there is an absorbing layer befor the reflecting one (like on a glass miror)
	int id; //default initialized to -1
	int status; //default initialized to 0 //0 inexistent in the world 1 existent in the world 2 existent but not placed yet
};

struct DynamicGeometry {
	int maxHyperphereNumber;
	HyperSphere hyperspheres[100];
	int maxAABBNumber;
	AABB AABBs[100];
};

//definition of structs in the ubo
struct Camera{
	vec4 pos;
	float fov;
	vec4 xHorizontalSubRetina;
	vec4 yVerticalSubRetina;
	vec4 zLookDir;
	vec4 wDir;
	float ZX;
	float ZY;
	float ZW;
	float WX;
	float WY;
};

struct Light{
	int type;
	vec3 color;
	vec4 pos;
};

//--> U B O <--
layout (binding = 1) uniform UBO {
	Light light[2];
    float time;
	float aspectRatio;
	int raybounces;
    bool playerAlive;
	float playerSucces;
    int scoped;
	float red;
	float green;
	float blue;
	int oct;
	float wMultiSamplingOffset;
	float wMultiStrength;
	bool wMultiSamplingEnabeled;
	bool aRoundIsGoingOn;
	int playerHP;
	int playerAmunition;
    float sunIntensity;
	Camera camera;
	DynamicGeometry dynamicGeometry;
}ubo;

layout(binding = 2) uniform sampler2D texSampler; //TEXTURE

void reflectRay(inout vec4 rayD, in vec4 mormal)
{
	rayD = rayD + 2.0 * -dot(mormal, rayD) * mormal;
}

// random number generator (using uv)
float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

// Lighting ========================================================= 
float lightDiffuse(vec4 normal, vec4 lightDir) 
{
	return clamp(dot(normal, lightDir), 0.0, 1.0); 
}

float lightSpecular(vec4 normal, vec4 lightDir, float specularFactor)
{
//	vec4 viewVec = normalize(ubo.camera.pos); 
//	vec4 halfVec = normalize(lightDir + viewVec);
//	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
//  --->
// avoid 2 vec4 elocations per call
	return pow(clamp(dot(normal, normalize(lightDir + normalize(ubo.camera.pos))), 0.0, 1.0), specularFactor);
}

// Hypersphere intersect ===========================================================

bool solveQuadratic(in float a, in float b, in float c, inout float x0, inout float x1)
{
    float discr = b * b - 4 * a * c;
    if (discr < 0) return false;
    else if (discr == 0) x0 = x1 = - 0.5 * b / a;
    else {
		if(a == 0){
			if(b == 0){
				if(c == 0){
					return true;
				}
				return(false);
			}
			x0 = x1 = - c / b;
		}
		float sqrtDiscr = sqrt(discr);
		x0 = fma(-0.5 / a, b + sqrtDiscr, 0.0);
		x1 = fma(-0.5 / a, b - sqrtDiscr, 0.0);
        //x0 = -0.5 * (b + sqrt(discr))/ a;
        //x1 = -0.5 * (b - sqrt(discr))/ a;
    }
//    if (x0 > x1){ //we first had a wrong swaping that did not seem to make up for any bug so we just remove it
//	//x0, x1 = x0, x1;
//	x0, x1 = x1, x0;
//	}
    return true;
}


//// Chat GPT suggestion for branchless version no big difference in FPS
//bool solveQuadratic(in float a, in float b, in float c, inout float x0, inout float x1)
//{
//    float discr = b * b - 4.0 * a * c;
//    float sqrtDiscr = sqrt(abs(discr));
//
//    float denom = 1.0 / (2.0 * a);
//
//    float q = -0.5 * (b + sign(b) * sqrtDiscr);
//
//    x0 = q / a;
//    x1 = c / q;
//
//    bool hasRealRoots = discr >= 0.0 && a != 0.0 && b != 0.0;
//
//    x0 = mix(x0, x1, x0 > x1);
//
//    return hasRealRoots;
//}

float hyperSphereIntersect(in vec4 rayO, in vec4 rayD, in HyperSphere hyperSphere)
{	
	if((hyperSphere.id >= 100000 && hyperSphere.id < 200000) && !ubo.aRoundIsGoingOn){
		return -1; //make reload sphere inexistent if no round is going on.
	}
	if((hyperSphere.id >= 200000 && hyperSphere.id < 300000) && !ubo.aRoundIsGoingOn){
		return -1; //make beacon sphere inexistent if no round is going on.
	}

	float t0, t1; // solutions for t if the ray intersects

	vec4 L = rayO - hyperSphere.pos;
    float b = 2 * dot(rayD,L);
    float c = dot(L,L)-hyperSphere.radius*hyperSphere.radius;
    //float a = 1; //dot(rayD,rayD) rayD is normalized
    //if (!solveQuadratic(a, b, c, t0, t1)) return -1;
    if (!solveQuadratic(1.0f, b, c, t0, t1)) return -1;

	if (t0*t1 < 0)  return -1; //different sign means we are inside (dont draw)

	if (t0 < 0) {
		t0 = t1; // if t0 is negative, let's use t1 instead
        if (t0 < 0) return -1; // both t0 and t1 are negative
    }
	return t0;
}

// AABB intersect ===========================================================
float AABBIntersect(in vec4 rayO, in vec4 rayD, in AABB aabb, inout vec4 normal)
{	
	//ACHTUNG !  division by zero may ocure !

	//intersection parameter ("time") with bounding hyperplanes
	float t0 = (aabb.pos.x - aabb.xRadius - rayO.x)/rayD.x;
	float t1 = (aabb.pos.x + aabb.xRadius - rayO.x)/rayD.x;

	float t2 = (aabb.pos.y - aabb.yRadius - rayO.y)/rayD.y;
	float t3 = (aabb.pos.y + aabb.yRadius - rayO.y)/rayD.y;

	float t4 = (aabb.pos.z - aabb.zRadius - rayO.z)/rayD.z;
	float t5 = (aabb.pos.z + aabb.zRadius - rayO.z)/rayD.z;

	float t6 = (aabb.pos.w - aabb.wRadius - rayO.w)/rayD.w;
	float t7 = (aabb.pos.w + aabb.wRadius - rayO.w)/rayD.w;

	float tmin = max(max(max(min(t0, t1), min(t2, t3)), min(t4, t5)), min(t6,t7));
	float tmax = min(min(min(max(t0, t1), max(t2, t3)), max(t4, t5)), max(t6,t7));

	// if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us
	if (tmax < 0)
	{
		return -1;
	}

	// if tmin > tmax, ray doesn't intersect AABB
	if (tmin > tmax)
	{
		return -1;
	}

	if(tmin == t0) normal = vec4(-1,0,0,0);
	if(tmin == t1) normal = vec4(1,0,0,0);
	if(tmin == t2) normal = vec4(0,-1,0,0);
	if(tmin == t3) normal = vec4(0,1,0,0);
	if(tmin == t4) normal = vec4(0,0,-1,0);
	if(tmin == t5) normal = vec4(0,0,1,0);
	if(tmin == t6) normal = vec4(0,0,0,-1);
	if(tmin == t7) normal = vec4(0,0,0,1);

	return tmin;
}


int intersect(in vec4 rayO, in vec4 rayD, inout float resT, inout vec4 resNormal, inout int geomType, bool firstOrderRay )//0 hypersphere 1 AABB
{
	int id = -1;
	resNormal = vec4(0,0,0,1); //default

	//with dynamicGeometry
	//hyperspheres
	for (int i = 0; i < ubo.dynamicGeometry.hyperspheres.length(); i++)
	{
		//if(ubo.dynamicGeometry.hyperspheres[i].status != 0){ //check for intersection with existing objects
		//if(ubo.dynamicGeometry.hyperspheres[i].status > 0){ //FRUST
		if((ubo.dynamicGeometry.hyperspheres[i].status != 0 && !firstOrderRay) || (ubo.dynamicGeometry.hyperspheres[i].status > 0 && firstOrderRay)){ //FRUST
			float tHyperSphere = hyperSphereIntersect(rayO, rayD, ubo.dynamicGeometry.hyperspheres[i]);
			if ((tHyperSphere > EPSILON) && (tHyperSphere < resT))
			{
				id = (ubo.dynamicGeometry.hyperspheres)[i].id;
				resT = tHyperSphere;
				geomType = 0;
			}
		}
	}
	//AABBs
	vec4 localNormal;
	for (int i = 0; i < ubo.dynamicGeometry.AABBs.length(); i++)
	{
		//if(ubo.dynamicGeometry.AABBs[i].status != 0){ //check for intersection with existing objects
		//if(ubo.dynamicGeometry.AABBs[i].status > 0){ //FRUST 
		if((ubo.dynamicGeometry.AABBs[i].status != 0 && !firstOrderRay) || (ubo.dynamicGeometry.AABBs[i].status > 0 && firstOrderRay)){ //FRUST
			float tAABB = AABBIntersect(rayO, rayD, ubo.dynamicGeometry.AABBs[i],localNormal);
			if ((tAABB > EPSILON) && (tAABB < resT))
			{
				id = (ubo.dynamicGeometry.AABBs)[i].id;
				resT = tAABB;
				geomType = 1;
				resNormal = localNormal;
			}
		}
	}

	return id;
}

//Return something != from -1 if hit no need to compute closest this time !
int intersectForShadow(in vec4 rayO, in vec4 rayD, in int lightType, in vec4 lightPos, bool firstOrderRay)//0 hypersphere 1 AABB
{
	float resTShadow = 10000; //the initialization is the maxlen for shadows to be cast on surfaces
	vec4 resNormal = vec4(1,1,1,1);
	int geomType = 1;

	int id = -1;
	resNormal = vec4(0,0,0,1); //default

	//with dynamicGeometry
	//hyperspheres
	for (int i = 0; i < ubo.dynamicGeometry.hyperspheres.length(); i++)
	{
		//if(ubo.dynamicGeometry.hyperspheres[i].status != 0){ //check for intersection with existing objects
		if(ubo.dynamicGeometry.hyperspheres[i].status > 0){ //FRUST
		//if((ubo.dynamicGeometry.hyperspheres[i].status != 0 && !firstOrderRay) || (ubo.dynamicGeometry.hyperspheres[i].status > 0 && firstOrderRay)){ //FRUST
			if(ubo.dynamicGeometry.hyperspheres[i].id > -1000 && ubo.dynamicGeometry.hyperspheres[i].id <= 1999) //not Black hole
			{
				float tHyperSphere = hyperSphereIntersect(rayO, rayD, ubo.dynamicGeometry.hyperspheres[i]);
				if ((tHyperSphere > EPSILON) && (tHyperSphere < resTShadow))
				{	
					if(lightType == 1){
						return(0);
					}
					if((lightType  == 0) && (tHyperSphere < length(rayO-lightPos))){
						return(0); //Return something != from -1 if hit no need to compute closest !
					}	
				}
			}
		}
	}
	//AABBs
	vec4 localNormal;
	for (int i = 0; i < ubo.dynamicGeometry.AABBs.length(); i++)
	{
		//if(ubo.dynamicGeometry.AABBs[i].status != 0){ //check for intersection with existing objects
		if(ubo.dynamicGeometry.AABBs[i].status > 0){ //FRUST
		//if((ubo.dynamicGeometry.AABBs[i].status != 0 && !firstOrderRay) || (ubo.dynamicGeometry.AABBs[i].status > 0 && firstOrderRay)){ //FRUST
			float tAABB = AABBIntersect(rayO, rayD, ubo.dynamicGeometry.AABBs[i],localNormal);
			if ((tAABB > EPSILON) && (tAABB < resTShadow))
			{
				if(lightType == 1){
					return(0);
				}
				if((lightType  == 0) && (tAABB < length(rayO-lightPos))){
					return(0); //Return something != from -1 if hit no need to compute closest !
				}	
			}
		}
	}
	return id;
}

vec4 hyperSphereNormal(in vec4 pos, in HyperSphere hyperSphere)
{	
	return normalize(pos-hyperSphere.pos);
}

//Black Hole //once beta is fixed precompute the coefficients
//returns an aproximation of the deviation angle as a function of the impact parameter r 
//with R_{schwartzshield} = beta*R and R the radius of the original hypersphere (do 4D computation of black hole to see if there is an intresting difference) 
float alphaHat(float r,float R,float beta){
	return( 2*log((1/beta-1.5)/(r/R*1/beta-1.5)) - 2/(1-1.5*beta)*(1 - r/R) );
}

//+++++++++++++++++++++++++++++++++++++++++++++++ N O I S E

//PERLIN

// random number generator (using uv and seed)
//float rand(vec2 co, float seed){
//    return fract(sin(dot(co * seed, vec2(12.9898, 78.233))) * 43758.5453);
//}
//
//// Hash function to generate a seed from an integer
//float hash(int value) {
//    value = (value << 13) ^ value;
//    return fract((value * (value * value * 15731 + 789221) + 1376312589) / 1073741824.0);
//}

//int intValue = 123; // Replace this with any integer value you want
//float seed = hash(intValue);
//float randomNumber = rand(uv, seed);

//// 2D Perlin Noise function with cubic interpolation
//float perlinNoise2D(vec2 P) {
//    // Integer coordinates of the cell containing the point P
//    ivec2 Pi = ivec2(floor(P));
//    // Fractional part of the coordinates
//    vec2 Pf = fract(P);
//
//    // Compute gradient vectors for four corners of the cell
//    vec2 grad00 = vec2(fract(sin(dot(Pi, vec2(127.1, 311.7))) * 43758.5453),
//                       fract(sin(dot(Pi, vec2(269.5, 183.3))) * 43758.5453));
//    vec2 grad10 = vec2(fract(sin(dot(Pi + ivec2(1, 0), vec2(127.1, 311.7))) * 43758.5453),
//                       fract(sin(dot(Pi + ivec2(1, 0), vec2(269.5, 183.3))) * 43758.5453));
//    vec2 grad01 = vec2(fract(sin(dot(Pi + ivec2(0, 1), vec2(127.1, 311.7))) * 43758.5453),
//                       fract(sin(dot(Pi + ivec2(0, 1), vec2(269.5, 183.3))) * 43758.5453));
//    vec2 grad11 = vec2(fract(sin(dot(Pi + ivec2(1, 1), vec2(127.1, 311.7))) * 43758.5453),
//                       fract(sin(dot(Pi + ivec2(1, 1), vec2(269.5, 183.3))) * 43758.5453));
//
//    // Compute dot products between gradients and vectors from the corners
//    float n00 = dot(grad00, Pf - vec2(0, 0));
//    float n10 = dot(grad10, Pf - vec2(1, 0));
//    float n01 = dot(grad01, Pf - vec2(0, 1));
//    float n11 = dot(grad11, Pf - vec2(1, 1));
//
//    // Interpolate along x-axis first
//    float n0 = mix(n00, n10, Pf.x);
//    float n1 = mix(n01, n11, Pf.x);
//
//    // Interpolate along y-axis
//    // Apply cubic interpolation to smooth the results
//    float n = mix(n0, n1, Pf.y);
//    
//    // Normalize the result between 0 and 1
//    return (n + 1.0) * 0.5;
//}
//
//// Compute Perlin noise octave at given scale
//float perlinNoiseOctave(vec2 P, float scale, int octave) {
//    float total = 0.0;
//    float frequency = 1.0 / scale;
//    float amplitude = 1.0;
//	float maxAmplitude = 0;
//
//    for (int i = 0; i < octave; i++) {
//        total += perlinNoise2D(P * frequency) * amplitude; //tune amplitude per octave ?
//		maxAmplitude += amplitude;
//        frequency *= 2.0;
//        amplitude *= 0.5;
//    }
//    return total/maxAmplitude;
//}

//// Compute 3D Perlin noise at a given point
//float perlinNoise3D(vec3 P) {
//    // Integer coordinates of the cell containing the point P
//    ivec3 Pi = ivec3(floor(P));
//    // Fractional part of the coordinates
//    vec3 Pf = fract(P);
//
//    // Compute gradient vectors for eight corners of the cell
//    vec3 grad000 = vec3(fract(sin(dot(Pi, vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi, vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi, vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad100 = vec3(fract(sin(dot(Pi + ivec3(1, 0, 0), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 0, 0), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 0, 0), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad010 = vec3(fract(sin(dot(Pi + ivec3(0, 1, 0), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 1, 0), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 1, 0), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad110 = vec3(fract(sin(dot(Pi + ivec3(1, 1, 0), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 1, 0), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 1, 0), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad001 = vec3(fract(sin(dot(Pi + ivec3(0, 0, 1), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 0, 1), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 0, 1), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad101 = vec3(fract(sin(dot(Pi + ivec3(1, 0, 1), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 0, 1), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 0, 1), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad011 = vec3(fract(sin(dot(Pi + ivec3(0, 1, 1), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 1, 1), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(0, 1, 1), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//    vec3 grad111 = vec3(fract(sin(dot(Pi + ivec3(1, 1, 1), vec3(127.1, 311.7, 534.3))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 1, 1), vec3(269.5, 183.3, 319.2))) * 43758.5453),
//                        fract(sin(dot(Pi + ivec3(1, 1, 1), vec3(419.2, 371.9, 684.5))) * 43758.5453));
//
//    // Compute dot products between gradients and vectors from the corners
//    float n000 = dot(grad000, Pf - vec3(0, 0, 0));
//    float n100 = dot(grad100, Pf - vec3(1, 0, 0));
//    float n010 = dot(grad010, Pf - vec3(0, 1, 0));
//    float n110 = dot(grad110, Pf - vec3(1, 1, 0));
//    float n001 = dot(grad001, Pf - vec3(0, 0, 1));
//    float n101 = dot(grad101, Pf - vec3(1, 0, 1));
//    float n011 = dot(grad011, Pf - vec3(0, 1, 1));
//    float n111 = dot(grad111, Pf - vec3(1, 1, 1));
//
//    // Interpolate along x-axis first
//    float n00 = mix(n000, n100, Pf.x);
//    float n01 = mix(n010, n110, Pf.x);
//    float n10 = mix(n001, n101, Pf.x);
//    float n11 = mix(n011, n111, Pf.x);
//
//    // Interpolate along y-axis
//    float n0 = mix(n00, n01, Pf.y);
//    float n1 = mix(n10, n11, Pf.y);
//
//    // Interpolate along z-axis
//    // Apply cubic interpolation to smooth the results
//    float n = mix(n0, n1, Pf.z);
//
////	// Normalize the result between 0 and 1
////    return (n + 1.0) * 0.5;
//	return n;
//}

//// Compute Perlin noise octave at given scale with normalization
//float perlinNoiseOctave(vec3 P, float scale, int octave) {
//    float total = 0.0;
//    float frequency = 1.0 / scale;
//    float amplitude = 1.0;
//    float maxAmplitude = 0.0;
//
//    for (int i = 0; i < octave; i++) {
//		//amplitude = octave - i;
//        total += perlinNoise3D(P * frequency) * amplitude;
//        maxAmplitude += amplitude;
//        frequency *= 2.0;
//        amplitude *= 0.5;
//    }
//
//	// Contrast
//    total *= 1.2;
//            
//    // Clipping
//    if (total > 1.0f) total = 1.0f;
//    else if (total < -1.0f) total = -1.0f;
// 
//    // Convert 1 to -1 into 255 to 0
//    total= ((total + 1.0f) * 0.5f);
//
//    return total;// / maxAmplitude;
//}

//WORLEY

//// 2D worley
//vec2 noise2x2(vec2 p) {
//  float x = dot(p, vec2(123.4, 234.5));
//  float y = dot(p, vec2(345.6, 456.7));
//  vec2 noise = vec2(x, y);
//  noise = sin(noise);
//  noise = noise * 43758.5453;
//  noise = fract(noise);
//  return noise;
//}
//
//vec3 worley2D(vec2 uv, float scale){
//	vec2 currentGridId = floor(uv / scale);
//	vec2 currentGridCoord = fract(uv / scale);
//	currentGridCoord = currentGridCoord - 0.5;
//
//	//red grid
//    vec2 redGridUv = currentGridCoord;
//    redGridUv = abs(redGridUv);
//    float distToEdgeOfGridCell = 2.0 * max(redGridUv.x, redGridUv.y);
//	vec3 redGridColor = vec3(smoothstep(0.9, 1.0, distToEdgeOfGridCell),0,0);
//
//	float minDistFromPixel = 100.0;
//	for (float i = -1.0; i <= 1.0; i++) {
//		for (float j = -1.0; j <= 1.0; j++) {
//			vec2 adjGridCoords = vec2(i, j);
//			vec2 pointOnAdjGrid = adjGridCoords;
//
//			vec2 noise = noise2x2(currentGridId + adjGridCoords);
//			pointOnAdjGrid = adjGridCoords + sin(ubo.time * noise) * 0.5;
//			//pointOnAdjGrid = adjGridCoords + sin(noise) * 0.5;
//
//			float dist = length(currentGridCoord - pointOnAdjGrid);
//			minDistFromPixel = min(dist, minDistFromPixel);
//		}
//	}
//	 
//	//return  vec3(minDistFromPixel) + vec3(smoothstep(0.9, 1.0, distToEdgeOfGridCell),0,0);
//	//return  vec3(minDistFromPixel);
//	return  vec3(1 - minDistFromPixel);
//}
//
//float worley2Df(vec2 uv, float scale){
//	vec2 currentGridId = floor(uv / scale);
//	vec2 currentGridCoord = fract(uv / scale);
//	currentGridCoord = currentGridCoord - 0.5;
//
//	float minDistFromPixel = 100.0;
//	for (float i = -1.0; i <= 1.0; i++) {
//		for (float j = -1.0; j <= 1.0; j++) {
//			vec2 adjGridCoords = vec2(i, j);
//			vec2 pointOnAdjGrid = adjGridCoords;
//
//			vec2 noise = noise2x2(currentGridId + adjGridCoords);
//			pointOnAdjGrid = adjGridCoords + sin(ubo.time * noise) * 0.5;
//			//pointOnAdjGrid = adjGridCoords + sin(noise) * 0.5;
//
//			float dist = length(currentGridCoord - pointOnAdjGrid);
//			minDistFromPixel = min(dist, minDistFromPixel);
//		}
//	}
//	return  minDistFromPixel;
//}
//
//float worley2DOctave(vec2 P, float scale, int octave) {
//    float total = 0.0;
//    float amplitude = 1.0;
//    float maxAmplitude = 0.0;
//	float nScale = scale;
//
//    for (int i = 0; i < octave; i++) {
//        total += worley2Df(P, nScale) * amplitude;
//        maxAmplitude += amplitude;
//        nScale *= 0.5;
//        amplitude *= 0.5;
//    }
//
//    // Normalize the result between 0 and 1
//    return total / maxAmplitude;
//}

// 3D worley
//vec3 noise3x3(vec3 p) {
//  float x = dot(p, vec3(123.4, 234.5, 657.2));
//  float y = dot(p, vec3(345.6, 456.7, 138.4));
//  float z = dot(p, vec3(445.5, 285.3, 244.8));
//  vec3 noise = vec3(x, y, z);
//  noise = sin(noise);
//  noise = noise * 43758.5453;
//  noise = fract(noise);
//  return noise;
//}

vec3 noise3x3(vec3 p) { //optimized version
  return fract(sin(vec3(
  dot(p, vec3(123.4, 234.5, 657.2)),
  dot(p, vec3(345.6, 456.7, 138.4)),
  dot(p, vec3(445.5, 285.3, 244.8))
  )) * 43758.5453);
}

//float worley3Df(vec3 uv, float scale){
//	vec3 currentGridId = floor(uv / scale);
//	vec3 currentGridCoord = fract(uv / scale);
//	currentGridCoord = currentGridCoord - 0.5;
//
//	float minDistFromPixel = 100.0;
//	for (float i = -1.0; i <= 1.0; i++) {
//		for (float j = -1.0; j <= 1.0; j++) {
//			for (float k = -1.0; k <= 1.0; k++) {
//				vec3 adjGridCoords = vec3(i, j, k);
//				vec3 pointOnAdjGrid = adjGridCoords;
//
//				vec3 noise = noise3x3(currentGridId + adjGridCoords);
//				pointOnAdjGrid = adjGridCoords + sin(ubo.time * noise) * 0.5;
//				//pointOnAdjGrid = adjGridCoords + sin(noise) * 0.5;
//
//				float dist = length(currentGridCoord - pointOnAdjGrid);
//				minDistFromPixel = min(dist, minDistFromPixel);
//			}
//		}
//	}
//	return  minDistFromPixel;
//}

float worley3Df(vec3 uv, float scale){ //no noticebl fps change...
	float minDistFromPixel = 100.0;
	for (float i = -1.0; i <= 1.0; i++) {
		for (float j = -1.0; j <= 1.0; j++) {
			for (float k = -1.0; k <= 1.0; k++) {
				minDistFromPixel = min(length(fract(uv / scale) - 0.5 - vec3(i, j, k) + sin(ubo.time * noise3x3(floor(uv / scale) + vec3(i, j, k))) * 0.5), minDistFromPixel);
			}
		}
	}
	return  minDistFromPixel;
}

//float worley3Dft(vec3 uv, float scale, float time){
//	vec3 currentGridId = floor(uv / scale);
//	vec3 currentGridCoord = fract(uv / scale);
//	currentGridCoord = currentGridCoord - 0.5;
//
//	float minDistFromPixel = 100.0;
//	for (float i = -1.0; i <= 1.0; i++) {
//		for (float j = -1.0; j <= 1.0; j++) {
//			for (float k = -1.0; k <= 1.0; k++) {
//				vec3 adjGridCoords = vec3(i, j, k);
//				vec3 pointOnAdjGrid = adjGridCoords;
//
//				vec3 noise = noise3x3(currentGridId + adjGridCoords);
//				pointOnAdjGrid = adjGridCoords + sin(time * noise) * 0.5;
//				//pointOnAdjGrid = adjGridCoords + sin(noise) * 0.5;
//
//				float dist = length(currentGridCoord - pointOnAdjGrid);
//				minDistFromPixel = min(dist, minDistFromPixel);
//			}
//		}
//	}
//	return  minDistFromPixel;
//}

float worley3Dft(vec3 uv, float scale, float time){
	float minDistFromPixel = 100.0;
	for (float i = -1.0; i <= 1.0; i++) {
		for (float j = -1.0; j <= 1.0; j++) {
			for (float k = -1.0; k <= 1.0; k++) {
				minDistFromPixel = min(length(fract(uv / scale)- 0.5 -  vec3(i, j, k) + sin(time * noise3x3(floor(uv / scale) + vec3(i, j, k))) * 0.5), minDistFromPixel);
			}
		}
	}
	return  minDistFromPixel;
}

float worley3DOctave(vec3 P, float scale, int octave) {
    float total = 0.0;
    float amplitude = 1.0;
    float maxAmplitude = 0.0;
	float nScale = scale;

    for (int i = 0; i < octave; i++) {
        total += worley3Df(P, nScale) * amplitude;
        maxAmplitude += amplitude;
        nScale *= 0.25; //0.5 usualy
        amplitude *= 0.25; //go faster to higher octaves
    }

    // Normalize the result between 0 and 1
    return total / maxAmplitude;
}

float worley3DOctavet(vec3 P, float scale, int octave, float time) {
    float total = 0.0;
    float amplitude = 1.0;
    float maxAmplitude = 0.0;
	float nScale = scale;

    for (int i = 0; i < octave; i++) {
        total += worley3Dft(P, nScale,time) * amplitude;
        maxAmplitude += amplitude;
        nScale *= 0.25; //0.5 usualy
        amplitude *= 0.25; //go faster to higher octaves
    }

    // Normalize the result between 0 and 1
    return total / maxAmplitude;
}

//float worley3DOctaveWarping(vec3 P, float scale, int octave, float time){
//	return worley3DOctavet( //worley3DOctaveWarping(P, scale, octave, time)
//	vec3( //new domain
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time)
//	) + vec3(0.254,0.354,0.125)
//	,scale,octave,time);
//}
//
//float worley3DOctaveDoubleWarping(vec3 P, float scale, int octave, float time){
//	return worley3DOctavet( //worley3DOctaveWarping(P, scale, octave, time)
//	vec3( //new domain
//	worley3DOctavet(vec3(
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time)
//	) + vec3(0.268,0.126,0.123)
//	, scale, octave, time),
//	worley3DOctavet(vec3(
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time)
//	) + vec3(0.257,0.367,0.534)
//	, scale, octave, time),
//	worley3DOctavet(vec3(
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time),
//	worley3DOctavet(P, scale, octave, time)
//	) + vec3(0.257,0.253,0.953)
//	, scale, octave, time)
//	) + vec3(0.254,0.354,0.125)
//	,scale,octave,time);
//}

// 4D worley

//vec4 noise4x4(vec4 p) {
//  float x = dot(p, vec4(123.4, 234.5, 657.2, 235.2));
//  float y = dot(p, vec4(345.6, 456.7, 138.4, 687.5));
//  float z = dot(p, vec4(445.5, 285.3, 244.8, 842.6));
//  float w = dot(p, vec4(685.9, 986.2, 147.4, 362.1));
//  vec4 noise = vec4(x, y, z, w);
//  noise = sin(noise);
//  noise = noise * 43758.5453;
//  noise = fract(noise);
//  return noise;
//}

vec4 noise4x4(vec4 p) {
  return fract(sin(vec4(
  dot(p, vec4(123.4, 234.5, 657.2, 235.2)),
  dot(p, vec4(345.6, 456.7, 138.4, 687.5)),
  dot(p, vec4(445.5, 285.3, 244.8, 842.6)),
  dot(p, vec4(685.9, 986.2, 147.4, 362.1))
  )) * 43758.5453);
}

float worley4Dft(vec4 uv, float scale, float time){
	float minDistFromPixel = 100.0;
	for (float i = -1.0; i <= 1.0; i++) {
		for (float j = -1.0; j <= 1.0; j++) {
			for (float k = -1.0; k <= 1.0; k++) {
				for (float l = -1.0; l <= 1.0; l++) {
					minDistFromPixel = min(length(fract(uv / scale) - 0.5 - vec4(i, j, k, l) + sin(time * noise4x4(floor(uv / scale) + vec4(i, j, k, l))) * 0.5), minDistFromPixel);
				}
			}
		}
	}
	return  minDistFromPixel;
}

float worley4DOctavet(vec4 P, float scale, int octave, float time) {
    float total = 0.0;
    float amplitude = 1.0;
    float maxAmplitude = 0.0;
	float nScale = scale;

    for (int i = 0; i < octave; i++) {
        total += worley4Dft(P, nScale,time) * amplitude;
        maxAmplitude += amplitude;
        nScale *= 0.25; //0.5 usualy
        amplitude *= 0.25; //go faster to higher octaves
    }

    // Normalize the result between 0 and 1
    return total / maxAmplitude;
}

float worley4DOctaveWarping(vec4 P, float scale, int octave, float time){
	float noise = worley4DOctavet(P, scale, octave, time);
	return worley4DOctavet( //worley3DOctaveWarping(P, scale, octave, time)
	vec4( //new domain
	noise,
	noise,
	noise,
	noise
	) + vec4(0.254,0.354,0.125,0.961)
	,scale,octave,time);
}

float worley4DOctaveDoubleWarping(in vec4 P,in float scale,in int octave,in float time, out float noise, out float NOISE){
	noise = worley4DOctavet(P, scale, octave, time);
	
	NOISE = worley4DOctavet( //worley3DOctaveWarping(P, scale, octave, time)
	vec4( //new domain
	noise,
	noise,
	noise,
	noise
	) + vec4(0.254,0.354,0.125,0.961)
	,scale,octave,time);

	return worley4DOctavet( //worley3DOctaveWarping(P, scale, octave, time)
	vec4( //new domain
	NOISE,
	NOISE,
	NOISE,
	NOISE
	) + vec4(0.254,0.354,0.125,0.961)
	,scale,octave,time);
}
//+++++++++++++++++++++++++++++++++++++++++++++++

//vec3 fogColor = vec3(0.6,0.8,0.9);
vec3 fogColor = vec3(0.0,0.0,0.0); //debug
vec3 fog(in float t, in vec3 color, in float breightness)
{
	return breightness*mix(color, fogColor, clamp(sqrt(t*t)/20.0, 0.0, 1.0));
}

// Miss shader ===========================================================
float halo(in vec4 rayD, in vec4 direction, int narowes){
	return pow(abs(dot(rayD,direction)),narowes);
}

float sunHalo(in vec4 rayD, in vec4 direction, int narowes){
	return 500000*2*pow(max(dot(rayD,direction)-0.95,0),narowes);
}

float intDistRayPlane(vec4 rayO, vec4 rayD, vec4 planeNormal, vec4 planeNormalOrigine){
	return dot(planeNormalOrigine-rayO,planeNormal)/dot(rayD,planeNormal);
}

vec4 intPointRayPlane(vec4 rayO, vec4 rayD, vec4 planeNormal, vec4 planeNormalOrigine){
	return rayO + rayD*intDistRayPlane(rayO, rayD, planeNormal, planeNormalOrigine);
}


vec3 missShader(in vec4 rayD, in vec4 rayO){ 
	float intensity = 0.1; //0.5 (09/11/2023)  0.1 (19/03/2024)
	float fogStrength = 0.0001; // 0.2; (09/11/2023)
	vec3 result = intensity*vec3(0,1,0); //default color green to be sure it has been updatet 


	if(rayD.y < 0){ //fake floor 
		result = intensity*vec3(0.4,0.9,0.5);
		//4d tiling of the floor.
		float twoPi = 2*3.14159;

		//motif
		vec4 squareCoord = intPointRayPlane(rayO, rayD + 0.01*vec4(0,0,0,1), vec4(0.0,-1.0,0.0,0.0), vec4(0.0,-200.0,0.0,0.0)); //to avoid overfinetuning on spawn 0.001*vec4(0,0,0,1)
//		result = intensity*vec3(
//			0.3*sin(0.1 + mod(squareCoord.w,twoPi))+0.1*mod(squareCoord.x,twoPi),
//			0.3*sin(0.1 + mod(squareCoord.x,twoPi))+0.1*mod(squareCoord.z,twoPi)+0.1*mod(squareCoord.w,twoPi),
//			0.3*sin(0.1 + mod(squareCoord.x,twoPi))+0.1*mod(squareCoord.w,twoPi)
//		) * vec3(0.1,1,0.5); //couleur de filtrage

		//result = vec3(1,1,1);

		//result = texture(texSampler, 0.01*vec2(squareCoord.x,squareCoord.z)).xyz;
		
//		//Classical "cube of images"
//		result = 
//		0.3 * texture(texSampler, 0.005*vec2(squareCoord.w,squareCoord.x)).xyz + 
//		0.3 * texture(texSampler, 0.005*vec2(squareCoord.x,squareCoord.z)).xyz +
//		0.3 * texture(texSampler, 0.005*vec2(squareCoord.z,squareCoord.w)).xyz; 
		
		float mult = 5;
		float modl = mult*100;//100;
		float xx = mod(squareCoord.x,modl)-modl*0.5;
		float zz = mod(squareCoord.z,modl)-modl*0.5;
		float ww = mod(squareCoord.w,modl)-modl*0.5;


		float xxx = mod(squareCoord.x,modl)/modl;
		float zzz = mod(squareCoord.z,modl)/modl;
		float www = mod(squareCoord.w,modl)/modl;

		float phase = mod(0.1*ubo.time, 1);

		if(xx*xx+zz*zz+ww*ww < 0.24*modl*modl){
		//result = vec3(1,0,0);
		result = 
		0.3 * texture(texSampler, (1/(mult*100))*vec2(squareCoord.w,squareCoord.x)).xyz + 
		0.3 * texture(texSampler, (1/(mult*100))*vec2(squareCoord.x,squareCoord.z)).xyz +
		0.3 * texture(texSampler, (1/(mult*100))*vec2(squareCoord.z,squareCoord.w)).xyz; 
		}

//		else if( (xx*xx+zz*zz+ww*ww > (phase+0.00-0.01)*modl*modl && xx*xx+zz*zz+ww*ww < (phase+0.00)*modl*modl)){
//			result = (xx*xx+zz*zz+ww*ww)/(0.25*modl*modl) * vec3(0.15,0.15,0.15);
//		}

		else if( 
		(xx*xx+zz*zz+ww*ww > (phase+0.00-0.01)*modl*modl && xx*xx+zz*zz+ww*ww < (phase+0.00)*modl*modl) ||
		(xx*xx+zz*zz+ww*ww > (phase+0.03-0.01)*modl*modl && xx*xx+zz*zz+ww*ww < (phase+0.03)*modl*modl) ||
		(xx*xx+zz*zz+ww*ww > (phase+0.09-0.01)*modl*modl && xx*xx+zz*zz+ww*ww < (phase+0.09)*modl*modl) ||
		(xx*xx+zz*zz+ww*ww > (phase+0.19-0.01)*modl*modl && xx*xx+zz*zz+ww*ww < (phase+0.19)*modl*modl)
		){
			result = (xx*xx+zz*zz+ww*ww)/(0.25*modl*modl) * vec3(0.15,0.15,0.15);
		}

//		else if(xx*xx+zz*zz+ww*ww > 0.24  *modl*modl && xx*xx+zz*zz+ww*ww < 0.245  *modl*modl) {
//			result = (xx*xx+zz*zz+ww*ww)/(0.25*modl*modl) * vec3(0.15,0.15,0.15);
//		}

		else{
		//result = xx*xx+zz*zz+ww*ww/(3*modl*modl)*vec3(0.06,0.05,0.25);
		//+ (1-xx*xx+zz*zz+ww*ww/(3*modl*modl)*vec3(0,0.5,0))*vec3(0,0.5,0);
		result = (1-sqrt(xxx*zzz*www))*vec3(1,1,1);
		}


		//imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), texture(texSampler, 4*vec2(uv.x * ubo.aspectRatio,1 - uv.y)));

		//temporari remove
		//result = fog(fogStrength*fogStrength*intDistRayPlane(rayO, rayD, vec4(0.0,-1.0,0.0,0.0), vec4(0.0,-2.0,0.0,0.0)), result,intensity);
	
		//FOG at horizon 
		float skyDist = abs(1/rayD.y);
		float skyWeight = exp(-0.04*skyDist);
		result = skyWeight*result + (1-skyWeight)*vec3(1,1,1);

	}

	else{ //sky
		vec4 squareCoord = intPointRayPlane(rayO, rayD, vec4(0.0,-1.0,0.0,0.0), vec4(0.0,200.0,0.0,0.0));		
		vec3 skyColor = vec3(3/255, 158/255, 255/255);
		vec3 cloudColor = vec3(1); //default cloud color
		vec3 defaultCloudColor = vec3(1);		
		
		//clouds //using worley (adding Perlin would use to much resources)

		int narownes = 5;
		if(ubo.oct != 0){
			float blueSkyAmount = 0.42;//0.42; //netween 1 and 0
			float wNoise = worley3DOctave(vec3(squareCoord.x,squareCoord.z,squareCoord.w),300,ubo.oct);
			if(wNoise > 1) wNoise = 1;
			if(wNoise < blueSkyAmount) wNoise = 0;
			else wNoise = (wNoise - blueSkyAmount)/(1-blueSkyAmount);

			float xh = wNoise * halo(rayD,vec4(1.0,0.0,0.0,0.0),narownes);
			float zh = wNoise * halo(rayD,vec4(0.0,0.0,1.0,0.0),narownes);
			float wh = wNoise * halo(rayD,vec4(0.0,0.0,0.0,1.0),narownes);
			cloudColor = (1 - xh)*(1 - zh)*(1 - wh)*vec3(1) + xh*vec3(1,0,0) + zh*vec3(1,1,0) + wh*vec3(0,1,0);
			result = cloudColor * wNoise + skyColor * (1-wNoise);
		}
		else result = skyColor;

		//FOG at horizon 
		float skyDist = 1/rayD.y;
		float skyWeight = exp(-0.02*skyDist);
		result = skyWeight*result + (1-skyWeight)*vec3(1,1,1);//*0.5*(defaultCloudColor+skyColor);//vec3(31/255, 158/255, 255/255));


		//HALO
		result += 4*sunHalo(rayD,normalize(ubo.light[0].pos),narownes)*ubo.light[0].color/(ubo.sunIntensity + 0.0000001);
		//result += 4*sunHalo(rayD,normalize(ubo.light[0].pos),narownes)*ubo.light[0].color;
	}

	//taking sun intensity and color into account
	//result = ubo.sunIntensity*vec3(result.x,(0.15 + 0.85*ubo.sunIntensity) * result.y,(0.85 * ubo.sunIntensity) * result.z);
	//result = ubo.sunIntensity*vec3(result.x,(0.15 + 0.85*ubo.sunIntensity) * result.y,(0.15 + 0.85 * ubo.sunIntensity) * result.z);
	result = ubo.sunIntensity*result;
//	if(ubo.sunIntensity == 0){
//		return vec3(0.2,0.2,0.2);
//	}
	return(result);
}

// Coordinate computation uvw 
vec3 uvw(vec4 normal) {
    float theta1 = atan(normal.z, normal.x);
    float theta2 = atan(sqrt(normal.x * normal.x + normal.z * normal.z), normal.y);
    float theta3 = atan(sqrt(normal.x * normal.x + normal.z * normal.z + normal.y * normal.y), normal.w);   
    return vec3(theta1, theta2, theta3);
}


// Render scene ===========================================================

vec3 renderScene(inout vec4 rayO, inout vec4 rayD, inout int id, inout float reflectionStrength, inout float reflectionFallOff, in bool noisedTextures, out float dist, out bool forceNextRay, bool firstOrderRay)
{
	//if(reflectionStrength == 0) return vec3(0); //entering with 0 means the resulting color is meaningles in the end computation !
	forceNextRay = false;
	vec3 color = vec3(0.0,0.0,0.0);
	float t = MAXLEN;

	int geomType;
	vec4 normal;
	// Get intersected object ID
	int objectID = intersect(rayO, rayD, t, normal, geomType, firstOrderRay);
	dist = t;

	if (objectID == -1) //if no hit
	{
		//in any case we do not want aditional rays to be computed. thus we set the reflection strength to 0
		reflectionStrength = 0;

		if(noisedTextures){
			return missShader(rayD, rayO); //color if nothing is hit ! (miss color);
		} 
		else return vec3(0,0,0);
	}
	
	vec4 pos = rayO + t * rayD; //hit point
	vec4 lightVec; 					
	

	vec3 selectColor = vec3(1.0,0.0,0.0);
	vec3 aboutToBePlacedColor = vec3(0.0,0.0,1.0);
	float sunLightIntensity = 1.0; //2.5 (19/03/2024)
	float playerLightIntensity = 10;
	//ambient light through miss shader and reflections
	vec4 resNormalShadow = vec4(1,1,1,1);
	int geomTypeShadow = 2;

	vec3 effectiveColor;
	// status 1 normal //sign determines if its inside the frustrum or not.
	// status 2 selected
	// status 3 about to be placed

	// Spheres
	if(geomType == 0)
	{
		for (int i = 0; i < ubo.dynamicGeometry.hyperspheres.length(); i++)
		{	
			if (objectID == (ubo.dynamicGeometry.hyperspheres)[i].id)
			{	
				//Black hole
				float beta = 0.25; //0.25
				//only needed if d>3/2 RS

				// get t0 and t1 for A //already computed but not kept... OPT
				if((ubo.dynamicGeometry.hyperspheres[i].id >= -1999 && ubo.dynamicGeometry.hyperspheres[i].id < -1000) && noisedTextures){//BH if hypersphere and -1999 < ID < -1000 //no BH in multisampling (makes bh look ugly or would need reflection to be performed)
				//if(true){
					float t0, t1; // solutions for t if the ray intersects
					vec4 L = rayO - ubo.dynamicGeometry.hyperspheres[i].pos;
					float b = 2 * dot(rayD,L);
					float c = dot(L,L)- ubo.dynamicGeometry.hyperspheres[i].radius* ubo.dynamicGeometry.hyperspheres[i].radius;
					solveQuadratic(1.0f, b, c, t0, t1);

					vec4 A = rayO + rayD*0.5*(t1 + t0);
					float d = length(A - ubo.dynamicGeometry.hyperspheres[i].pos);

					if(d < 1.5*beta*ubo.dynamicGeometry.hyperspheres[i].radius){
						//so close that the ray can't escape

//						reflectionFallOff = 0; 
//						reflectionStrength = 0;
						id = objectID;
						dist = MAXLEN; //no further reflection after perfect black
						return vec3(0); //Black of the center of the BH !
					}
					else{
						vec4 u = normalize(A - ubo.dynamicGeometry.hyperspheres[i].pos);
						float alpha = alphaHat(d,ubo.dynamicGeometry.hyperspheres[i].radius,beta);
						//compute B
						rayO = A + d*(sin(alpha)*rayD - (1-cos(alpha))*u);
						rayD = cos(alpha)*rayD - sin(alpha)*u;
//						reflectionFallOff = 1; //to have 100% weight on the comming ray ! 
//						reflectionStrength = 1;
						id = objectID;
						forceNextRay = true;
						reflectionFallOff = 1; //to avoid early return !!
						reflectionStrength = 1; //to avoid early return !!
						return vec3(0,0,0); //should not mater wich color is chosen.
					}
				}

				int status = abs(ubo.dynamicGeometry.hyperspheres[i].status); 
				effectiveColor = 
				(1-min(1,status-1))*(ubo.dynamicGeometry.hyperspheres)[i].diffuse+ 
				min(1,status-1)*(
				(3-status)*selectColor + 
				(status - 2)*aboutToBePlacedColor
				);

				normal = hyperSphereNormal(pos, (ubo.dynamicGeometry.hyperspheres)[i]);
				reflectionFallOff = ubo.dynamicGeometry.hyperspheres[i].reflectionFallOff;
				reflectionStrength = ubo.dynamicGeometry.hyperspheres[i].reflectionStrength;

				//RELOAD SPHERES
				if((ubo.dynamicGeometry.hyperspheres[i].id >= 100000 && ubo.dynamicGeometry.hyperspheres[i].id < 200000) && noisedTextures){ //Reload sphere rendering			
					vec4 radial = normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos);
					float y = dot(radial,vec4(0,1,0,0));
					radial = radial - vec4(0,1,0,0)*y; //remove vertical component from vector
					vec4 dir = normalize(rayO-ubo.dynamicGeometry.hyperspheres[i].pos);
					radial = radial - dir*dot(radial,dir); //remove component allong dir
					float x = length(radial);


					if(y > 0){
						if(y < 0.7*9*(x - 0.333)*(x - 0.333) && x < 0.333){
							return (1 - x/(0.333 - sqrt(y/(0.7*9))) * x/(0.333 - sqrt(y/(0.7*9))) )*vec3(0.9,0.7,0); 
						}	
					}
					if(y < 0){
						if(y>3*x -1){
							return (1 - x/(0.333*(y+1))*x/(0.333*(y+1)) )*vec3(0.9,0.7,0);
						}	
					}


					float theta = atan(y/x);
					radial = normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos);
					normal = -dir + pow((1 - (x*x + y*y)),9)*radial*sin(5*2*3.14159*theta);

					//make relection decrease realy close to boarder
					reflectionFallOff = 0.9*(1 - pow((x*x + y*y),5));
					reflectionStrength = 0.9*(1 - pow((x*x + y*y),5));   

				}

				//BEACON SPHERES
				if((ubo.dynamicGeometry.hyperspheres[i].id >= 200000 && ubo.dynamicGeometry.hyperspheres[i].id < 300000) && noisedTextures){ //beacon sphere rendering	
					vec3 beaconColor = vec3(1,0,1);
					int waveDir = 1;
					if(ubo.dynamicGeometry.hyperspheres[i].reflectionFallOff > 0.3){
						waveDir = -1;
						beaconColor = vec3(0,0,1);
					} 
					vec4 dir = normalize(rayO-ubo.dynamicGeometry.hyperspheres[i].pos);
					vec4 orth = pos-ubo.dynamicGeometry.hyperspheres[i].pos; //sphere center, impact on sphere vector
					orth = normalize(orth - dot(orth,dir)*dir); //suppres projection on dir
					float radDist = length(pos-ubo.dynamicGeometry.hyperspheres[i].pos - dot(pos-ubo.dynamicGeometry.hyperspheres[i].pos,dir)*dir);
					normal = normalize(-dir + radDist*0.1*sin(15*radDist + waveDir*1.5*ubo.time) * orth); //add sine vawe with temporal phase.
					//normal = normalize(-dir + 0.1*orth); //add sine vawe with temporal phase.
					reflectionFallOff = 0.9;
					reflectionStrength = 0.91;
					if(abs(dot(normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos),-dir)) < 0.7) return  (1-abs(dot(normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos),-dir))/0.7)*beaconColor;
					if(abs(dot(normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos),-dir)) > 0.999 && abs(dot(normalize(pos-ubo.dynamicGeometry.hyperspheres[i].pos),-dir)) < 0.9992) return  beaconColor;
					if(sin(15*radDist - waveDir*1.5*ubo.time) < -0.99) return beaconColor;
				}

				vec3 skinColor = (ubo.dynamicGeometry.hyperspheres)[i].diffuse;
				
				//LANCELOT TIGER SKIN
				if(ubo.dynamicGeometry.hyperspheres[i].id<0 && noisedTextures){ //mob //generate tiger like skin for lancelots
				//if(true){ //all balls
					float s1 = 0.2;
					float s2 = 0.8;
					vec3 uvw = uvw(normal);
					//float factor = 0.5*(sin(worley3Dft(3*uvw,1,1)*45)+1); //noise between 0 and 1
					//float factor = 0.5*(sin(worley3DOctavet(uvw, 1, 3, 1000+1000*ubo.dynamicGeometry.hyperspheres[i].id)*45)+1); //noise between 0 and 1
					float factor = 0.5*(sin(worley3DOctavet(vec3(uvw.x,0.2*uvw.y,0.2*uvw.z), 1, 3, 1000+1000*ubo.dynamicGeometry.hyperspheres[i].id)*45)+1); //noise between 0 and 1
					//float factor = 0.5*(1 +sin(45 * uvw.y));

					if(factor >= s2){//orange stripes fading to white
						float weight = uvw.y/3.14159;
						//weight = pow(weight,5);
						weight =smoothstep(0.7, 0.85, uvw.y/3.14159);
						//if(weight > 0.2) skinColor = vec3(1.0,0.0,0.0);
						skinColor = (1-weight) * skinColor + weight*vec3(1.0,1.0,1.0);
						reflectionFallOff = 0.00;// (1-0.6*factor);
						reflectionStrength = 0.00;// (1 -0.6*factor);
					}
					if(factor <= s1){//black stripes
						skinColor = vec3(0,0,0.1);
						reflectionFallOff *= 0;//(1-0.6*(factor + s1));
						reflectionStrength *= 0;//(1-0.6*(factor + s1));

						//reflectionFallOff *= 1;
						//reflectionStrength *= 1;
					}
					if(factor < s2 && factor > s1)
					{// do not degrade reflection coef, start with a big one
						//reflectionFallOff *= 1;
						//reflectionStrength *= 1;

//						skinColor = vec3(0,0,0.1);
//						reflectionFallOff *= 0;//(1-0.6*(factor + s1));
//						reflectionStrength *= 0;//(1-0.6*(factor + s1));
					}
				}

				color = vec3(0.0,0.0,0.0);
				for(int j = 0; j < ubo.light.length(); j++)
				{	
					vec4 lightVec = normalize(ubo.light[j].pos - (1-ubo.light[j].type)*pos);	
					//tester si il y a un obstacle entre la source et l'objet pour les ombres
					if(intersectForShadow(pos,lightVec,ubo.light[j].type,ubo.light[j].pos, firstOrderRay) == -1){
						float lightDistCubed = (1-ubo.light[j].type)*pow(dot(ubo.light[j].pos - pos,ubo.light[j].pos - pos),3/2) + ubo.light[j].type;
						//float diffuse = lightDiffuse(normal, lightVec)/lightDistCubed * 0.9 + 0.1 * lightDiffuse(normal, lightVec)/pow(lightDistCubed,3); //geometric decreas of light intensity is cubic in 4 Dim //add slow decreasing light so that on can see further at night (already often saturated)
						float diffuse = lightDiffuse(normal, lightVec)/lightDistCubed; //geometric decreas of light intensity is cubic in 4 Dim //add slow decreasing light so that on can see further at night (already often saturated)
						float specular = lightSpecular(normal, lightVec, (ubo.dynamicGeometry.hyperspheres)[i].specular)/lightDistCubed;
						color += (playerLightIntensity*(1-ubo.light[j].type) + sunLightIntensity*ubo.light[j].type)*(diffuse * skinColor + specular)*ubo.light[j].color;			
					}
				}		
			}
		}
	}
	

	// AABBs
	if(geomType == 1)
	{
		for (int i = 0; i < ubo.dynamicGeometry.AABBs.length(); i++)
		{	
			if (objectID == (ubo.dynamicGeometry.AABBs)[i].id)
			{	
				int status = abs(ubo.dynamicGeometry.AABBs[i].status); 
				effectiveColor = 
				(1-min(1,status-1))*(ubo.dynamicGeometry.AABBs)[i].diffuse+ 
				min(1,status-1)*(
				(3-status)*selectColor + 
				(status - 2)*aboutToBePlacedColor
				);

				reflectionFallOff = ubo.dynamicGeometry.AABBs[i].reflectionFallOff;
				reflectionStrength = ubo.dynamicGeometry.AABBs[i].reflectionStrength;
				color = vec3(0.0,0.0,0.0);

				
				//think of pos as uvwx 
				float scaleInv = 0.5;
				float n0 = 1;
				float n1 = 1;
				float n2 = 1;
				if(noisedTextures){
					n2 = worley4DOctaveDoubleWarping(pos, scaleInv, 2, ubo.green*10, n0, n1);
					normal = normalize(normal + 0.01*(n2-0.5)*vec4(1,1,1,1));
				} 

                

				for(int j = 0; j < ubo.light.length(); j++)
				{	
					vec4 lightVec = normalize(ubo.light[j].pos - (1-ubo.light[j].type)*pos); 	
					//tester si il y a un obstacle entre la source et l'objet pour les ombres
					if(intersectForShadow(pos,lightVec,ubo.light[j].type,ubo.light[j].pos, firstOrderRay) == -1){
						float lightDistCubed = (1-ubo.light[j].type)*pow(dot(ubo.light[j].pos - pos,ubo.light[j].pos - pos),3/2) + ubo.light[j].type;
						float diffuse = lightDiffuse(normal, lightVec)/lightDistCubed;
						float specular = lightSpecular(normal, lightVec, (ubo.dynamicGeometry.AABBs)[i].specular)/lightDistCubed;
						color += (playerLightIntensity*(1-ubo.light[j].type) + sunLightIntensity*ubo.light[j].type)*(diffuse * (ubo.dynamicGeometry.AABBs)[i].diffuse*n2*vec3(n1,n1,n1) + specular)*ubo.light[j].color;				
						//color += (playerLightIntensity*(1-ubo.light[j].type) + sunLightIntensity*ubo.light[j].type)*(diffuse * (ubo.dynamicGeometry.AABBs)[i].diffuse + specular)*ubo.light[j].color;				
					}
				}		
			}
		}
	}

	if (id == -1) return color; //if nothing is hit we can return the miss color before doing further computations

	id = objectID;

//	// Shadows
//	t = length(ubo.lightPos - pos);
//	color *= calcShadow(pos, lightVec, id, t);
//	

	// Fist desactivated.
	// Fog
	//color = fog(t, color,1);	

	// Reflect ray for next render pass
	reflectRay(rayD, normal);
	rayO = pos;	

	return color;
}

//implemented outside the main function to make multisampling easyer
vec3 rayResult(in vec4 rayO,in vec4 rayD, inout float reflectionStrength, inout float reflectionFallOff, in bool noisedTextures){
	// Basic color path
	int id = 0;
	float t;
	bool forceNextRay;
	vec3 finalColor = renderScene(rayO, rayD, id, reflectionStrength, reflectionFallOff, noisedTextures, t, forceNextRay, true);
	if(t == MAXLEN) finalColor; //if nothing is hit there is no need to compute further reflections !
	float maxT = t;

	// Reflection
	float cumulatedReflectionFallOff = 1;
	float oldReflectionStrength = 1;
	float oldReflectionFallOff = 1;
	if (REFLECTIONS)
	{
		for (int i = 0; i < ubo.raybounces; i++)  
		{
			if(reflectionStrength == 0) break;

			oldReflectionFallOff = reflectionFallOff;
			oldReflectionStrength = reflectionStrength;
			vec3 reflectionColor = renderScene(rayO, rayD, id, reflectionStrength, reflectionFallOff,noisedTextures, t, forceNextRay, false);
			finalColor = mix(reflectionColor, finalColor, 1.0 - oldReflectionStrength*cumulatedReflectionFallOff*oldReflectionFallOff);
			//finalColor = mix(reflectionColor, finalColor, 1.0 - oldReflectionStrength*oldReflectionFallOff);
			if(t == MAXLEN) return finalColor; //if nothing is hit there is no need to compute further reflections !
			cumulatedReflectionFallOff *= oldReflectionFallOff;
			if(t > 100 && !forceNextRay) return finalColor; //don't compute more reflections if object is far away. //10 = maxmultireflection dist 
			if(maxT > 100  && !forceNextRay) return finalColor; // if object is far away from fitst ray ! (or other non thought of config)
			//return vec3(0,1,0) or vec3(1,0,0) to see perfomed culling;
		}
	}
	return finalColor;
}

vec3 rayResultNoReflection(in vec4 rayO,in vec4 rayD, inout float reflectionStrength, inout float reflectionFallOff, in bool noisedTextures){
	// Basic color path
	int id = 0;
	float t;
	bool forceNextRay;
	vec3 finalColor = renderScene(rayO, rayD, id, reflectionStrength, reflectionFallOff, noisedTextures, t, forceNextRay, false); //use frustrumculling in wMS at all order
	return finalColor;
}
//  --> MAIN <--

void main() 
{
	float noisePower = 0.0001;
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	vec4 rayO = ubo.camera.pos;
	
	//with noise
//	vec4 rayD = normalize(
//	ubo.camera.zLookDir + 
//	ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1+rand(uv)*noisePower)/ubo.camera.fov +
//	ubo.camera.yVerticalSubRetina*(2.0*uv.y-1+rand(uv+vec2(667,666))*noisePower)/ubo.camera.fov
//	);

	//without noise
	vec4 rayD = normalize(
	ubo.camera.zLookDir + 
	ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/(ubo.camera.fov*pow(2,ubo.scoped)) +
	ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/(ubo.camera.fov*pow(2,ubo.scoped))
	);

	float reflectionStrength = 1; //previously use uninitalized! causing funy flahy noise effects
	float reflectionFallOff = 1;

	//Description of the previous line
	//vec4 rayD = nomrmalize( looking direction  +  (divertion from looking direction in the two axis of the 2d retina (x,y) are default));
	
//	// Basic color path
//	int id = 0;
//	vec3 finalColor = renderScene(rayO, rayD, id);
//
//	// Reflection
//	if (REFLECTIONS)
//	{
//		float reflectionStrength = REFLECTIONSTRENGTH;
//		for (int i = 0; i < RAYBOUNCES; i++)
//		{
//			vec3 reflectionColor = renderScene(rayO, rayD, id);
//			finalColor = (1.0 - reflectionStrength) * finalColor + reflectionStrength * mix(reflectionColor, finalColor, 1.0 - reflectionStrength);			
//			reflectionStrength *= REFLECTIONFALLOFF;
//		}
//	}
	
	float deviationStrength = 0.001; //for multisampling

	// <---< GUI parameters >--->
	float guiScale = 1.0;
	vec2 ruv = vec2((uv.x-0.005)*ubo.aspectRatio,(uv.y+0.005));
	//- and + 0.005 for the rainbow border


	//player gyro parameters
	float gyriScale = 1.0;
	float barWidth = 0.005;
	float barLength = 0.9*0.2;

	vec2 gyr1center = vec2(0.1,1 - 0.1);
	vec2 gyr2center = vec2(0.1,1 - 0.1) + vec2(0.0,-0.2);
	vec2 gyr3center = vec2(0.1,1 - 0.1) + 2*vec2(0.0,-0.2);


	vec2 gyr1loc = 0.5 * barLength * vec2(ubo.camera.zLookDir.x,ubo.camera.zLookDir.y) + gyr1center;
	vec2 gyr2loc = 0.5 * barLength * vec2(ubo.camera.zLookDir.z,ubo.camera.zLookDir.w) + gyr2center;
	vec2 gyr3loc = 0.5 * barLength * vec2(ubo.camera.xHorizontalSubRetina.x,ubo.camera.xHorizontalSubRetina.w) + gyr3center;

	vec3 barColor = vec3(0.0,1.0,0.0);
	vec3 pointerColor = vec3(1.0,0.0,0.0);
	vec3 lookGyroColor = 4.5*abs(rand(uv))*vec3(0.0,0.1,0.3);
	vec3 retinaGyroColor = 4.5*abs(rand(uv))*vec3(0.2,0.0,0.2);

	//Croshair parameters
	float croshairWidth = 0.0025;
	float croshairLength = 0.025;
	float croshairBorder = 0.002;
	float scopedCroshairWidth = 0.0025*0.5;
	vec3 finalColor = vec3(0.0,0.0,1.0);
	//vec3 uniInitColor;

	float screenHightNormalizedDistenceToCenter = ubo.aspectRatio*abs(2.0*uv.x-1)*ubo.aspectRatio*abs(2.0*uv.x-1)+abs(2.0*uv.y-1)*abs(2.0*uv.y-1);
	float scopeSize = 0.9; //respective to the screen hight

	//Bullet test precompute
	
	//centers are ((0.06+ 0.04*i)/ubo.aspectRatio,0.06)

	bool onBullet = false;
	int bulletIndex = 0;
	vec2 uvn = vec2(uv.x*ubo.aspectRatio,1-uv.y);
	for(int i = 0; i < ubo.playerAmunition; i++){
		vec2 bulletCoord = uvn-vec2((0.06+ 0.03*i),0.06);
		if(bulletCoord.y > 0 && bulletCoord.y < 0.01){
			if((bulletCoord.y)*(bulletCoord.y)/0.01 > abs(bulletCoord.x)){
				onBullet = true;
				bulletIndex = i;
			}	
		}
		if(bulletCoord.y > 0.01){
			if(-(bulletCoord.y)/3 +0.015> abs(bulletCoord.x)){
				onBullet = true;
				bulletIndex = i;
			}	
		}
	}

//	bool onBullet = false;
//	for(int i = 0; i < ubo.playerAmunition; i++){
//		if(    (1-uv.y) < 0.05 + 2 * 0.02 
//			&& (1-uv.y) > (0.05 + 2 * 0.02-0.02)
//			&& uv.x*ubo.aspectRatio > 0.05 + 0.04*i
//			&& uv.x*ubo.aspectRatio < 0.05 + 0.04*i +0.02){ 
//				onBullet = true;
//				
//		}
//	}

	if(screenHightNormalizedDistenceToCenter > scopeSize && ubo.scoped != 0){ 
		finalColor = vec3(0.02,0.02,0.02);
		//finalColor = uniInitColor;
	}
	//PLAYER_GYRO RENDERING
//	if( (ruv.x < 0.2*gyriScale) && ((1-ruv.y) < 3*0.2*gyriScale) ){
//		finalColor = pow(abs(1-length(ruv - gyr3center)/barLength),2)*retinaGyroColor;
//		if((1-ruv.y) < 1*0.2*gyriScale){
//			finalColor = pow(abs(1-length(ruv - gyr1center)/barLength),2)*lookGyroColor;
//		}
//		else if((1-ruv.y) < 2*0.2*gyriScale){
//			finalColor = pow(abs(1-length(ruv - gyr2center)/barLength),2)*lookGyroColor;
//		}
//
//		//gyr1
//		if( 
//		((abs((ruv - gyr1center).x) < barWidth*0.5) && (abs((ruv - gyr1center).y) < barLength*0.5)) 
//		|| ((abs((ruv - gyr1center).y) < barWidth*0.5) && (abs((ruv - gyr1center).x) < barLength*0.5))
//		){
//			finalColor = barColor;
//		}
//		if(length(gyr1loc - ruv) < 0.005){
//			finalColor = pointerColor;
//		}
//
//		//gyr2
//		if( 
//		((abs((ruv - gyr2center).x) < barWidth*0.5) && (abs((ruv - gyr2center).y) < barLength*0.5)) 
//		|| ((abs((ruv - gyr2center).y) < barWidth*0.5) && (abs((ruv - gyr2center).x) < barLength*0.5))
//		){
//			finalColor = barColor;
//		}
//		if(length(gyr2loc - ruv) < 0.005){
//			finalColor = pointerColor;
//		}
//
//		//gyr3
//		if( 
//		((abs((ruv - gyr3center).x) < barWidth*0.5) && (abs((ruv - gyr3center).y) < barLength*0.5)) 
//		|| ((abs((ruv - gyr3center).y) < barWidth*0.5) && (abs((ruv - gyr3center).x) < barLength*0.5))
//		){
//			finalColor = barColor;
//		}
//		if(length(gyr3loc - ruv) < 0.005){
//			finalColor = pointerColor;
//		}
//	}

	//COSSHAIR RENDERING
	else if(ubo.scoped == 0 && ((ubo.aspectRatio*abs(2.0*uv.x-1) < croshairWidth+croshairBorder && abs(2.0*uv.y-1) < croshairLength+croshairBorder) || (ubo.aspectRatio*abs(2.0*uv.x-1) < croshairLength+croshairBorder && abs(2.0*uv.y-1) < croshairWidth+croshairBorder)) ){
		if(ubo.scoped == 0 &&  ((ubo.aspectRatio*abs(2.0*uv.x-1) < croshairWidth && abs(2.0*uv.y-1) < croshairLength) || (ubo.aspectRatio*abs(2.0*uv.x-1) < croshairLength && abs(2.0*uv.y-1) < croshairWidth) )){
			finalColor = vec3(0.0,1,0.0);
		}
		else{
			finalColor = vec3(0.2,0.2,0.2);
		}
	}
	//SCOPED
	else if(ubo.scoped != 0 && ((ubo.aspectRatio*abs(2.0*uv.x-1) < scopedCroshairWidth) || (abs(2.0*uv.y-1) < scopedCroshairWidth)) ){
		finalColor = vec3(0,0,0);
	}

	//HP rendering
	else if(ubo.aRoundIsGoingOn 
	&& (1-uv.y) < 0.05 
	&& (1-uv.y) > (0.05-0.02)
	&& uv.x*ubo.aspectRatio> 0.05
	&& uv.x*ubo.aspectRatio< 0.4
	){
		float yy = (1-uv.y)/0.02 + 1 - 0.05/0.02;
		float yyy = 4*yy*yy - 4*yy + 1;
		float xx = ubo.playerHP*0.01*(0.4-0.05)/ubo.aspectRatio + 0.05/ubo.aspectRatio;
		//float xxx = uv.x/(0.2-0.05) + 1 -0.2/(0.2-0.05);
		//float xxxx = 4*xxx*xxx - 4*xxx + 1;
		//float xxxxx = (1-pow(xxxx,17));
		//*xxxxx

		if(uv.x < xx){
			finalColor = (1.0 - yyy)*vec3(0.7,0.1,0.2); //*xxxxx
		}
		else{
			finalColor = (1.0 - yyy)*vec3(0.2,0.2,0.2);
		}
	}

	//Amunition rendering
	else if(ubo.aRoundIsGoingOn && onBullet){	
		vec2 uvn = vec2(uv.x*ubo.aspectRatio,1-uv.y);
		vec2 bulletCoord = uvn-vec2((0.06+ 0.03*bulletIndex),0.06);
		if(bulletCoord.y > 0 && bulletCoord.y < 0.01){
			finalColor = (1-abs(bulletCoord.x)/((bulletCoord.y)*(bulletCoord.y)/0.01)*abs(bulletCoord.x)/((bulletCoord.y)*(bulletCoord.y)/0.01)) * vec3(0.9,0.7,0);	
		}
		if(bulletCoord.y > 0.01){
			finalColor = (1-abs(bulletCoord.x)/(-(bulletCoord.y)/3 +0.015)*abs(bulletCoord.x)/(-(bulletCoord.y)/3 +0.015)) * vec3(0.9,0.7,0);	
		}
	}

//	else if(ubo.aRoundIsGoingOn
//	&& (1-uv.y) < 0.25 
//	&& (1-uv.y) > (0.25-0.02)
//	&& uv.x*ubo.aspectRatio > 0.05
//	&& uv.x*ubo.aspectRatio < 0.05 + 0.02 + 0.04*5.0){ 
//		finalColor = vec3(0,0,0);
//		
//		bool onBullet = false;
//		for(int i = 0; i < ubo.playerAmunition; i++){
//			if(    (1-uv.y) < 0.25 
//				&& (1-uv.y) > (0.25-0.02)
//				&& uv.x*ubo.aspectRatio > 0.05 + 0.04*i
//				&& uv.x*ubo.aspectRatio < 0.05 + 0.04*i +0.02){ 
//					onBullet = true;
//					finalColor = vec3(1,1,0);
//			}
//		}
//	}


	//4D RENDERING
	else{
		if(ubo.scoped != 0){
		rayO = rayO + ubo.camera.zLookDir * 1.2;//the 1.2 depends on the weapon lenght.
		rayD = normalize(
			ubo.camera.zLookDir + 
			(1 + pow((screenHightNormalizedDistenceToCenter/scopeSize)*1.0/0.8 ,20))* //distortion factor
			(ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/(ubo.camera.fov*pow(2,ubo.scoped)) +
			ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/(ubo.camera.fov*pow(2,ubo.scoped)))
			);
		}
		if(ubo.scoped != 0 && screenHightNormalizedDistenceToCenter > 0.8*scopeSize){//scoped and close to border
//			vec4 normalToTube = normalize(vec4(rayD.x,rayD.y,0,0));
//			rayD = rayD - 2*dot(rayD,normalToTube)*normalToTube;
			
			//reflection of direction
			rayD.x = -rayD.x;
			rayD.y = -rayD.y; 

//			//correction of origine
//			float scopeTubeRadius = 0.5;
//			rayO = rayO + scopeTubeRadius*vec4(rayD.x,rayD.y,1/screenHightNormalizedDistenceToCenter,0);

			finalColor = 0.1*rayResult(rayO, rayD, reflectionStrength, reflectionFallOff,true) * vec3(1,0.7,0.5) + 0.0*0.2*vec3(0.2,0.2,0.2);
		}
		else{
			if(!ubo.wMultiSamplingEnabeled)finalColor = rayResult(rayO, rayD, reflectionStrength, reflectionFallOff, true);// * vec3(ubo.red,ubo.green,ubo.blue);
			else{
//				finalColor = 
//				(1-ubo.wMultiStrength) * rayResult(rayO, rayD, reflectionStrength, reflectionFallOff)+// * vec3(ubo.red,ubo.green,ubo.blue)+ //main
//				0.5 * ubo.wMultiStrength * exp(ubo.red*log(vec3(1,0,0)*length(rayResultNoReflection(rayO, normalize(rayD + ubo.wMultiSamplingOffset*vec4(0,0,0,1)), reflectionStrength, reflectionFallOff))))+ //ana
//				0.5 * ubo.wMultiStrength * exp(ubo.red*log(vec3(0,0,1)*length(rayResultNoReflection(rayO, normalize(rayD - ubo.wMultiSamplingOffset*vec4(0,0,0,1)), reflectionStrength, reflectionFallOff)))); //kata			
//				//finalColor = exp(1.5log(finalColor)); //	to enhance contrast
//				//finalColor = exp(ubo.red*log(finalColor)); //	to enhance contrast

//				finalColor = 
//				ubo.green*(1-ubo.wMultiStrength) * rayResult(rayO, rayD, reflectionStrength, reflectionFallOff)+// * vec3(ubo.red,ubo.green,ubo.blue)+ //main
//				0.5 * ubo.wMultiStrength * exp(ubo.red*log(vec3(1,0.5,0)*length(rayResultNoReflection(rayO, normalize(rayD + ubo.wMultiSamplingOffset*vec4(0,0,0,1)), reflectionStrength, reflectionFallOff))))+ //ana
//				ubo.blue*0.5 * ubo.wMultiStrength * exp(ubo.red*log(vec3(0,0.5,1)*length(rayResultNoReflection(rayO, normalize(rayD - ubo.wMultiSamplingOffset*vec4(0,0,0,1)), reflectionStrength, reflectionFallOff)))); //kata			
//				//finalColor = exp(1.5log(finalColor)); //	to enhance contrast
//				//finalColor = exp(ubo.red*log(finalColor)); //	to enhance contrast
				
				//XOR the red and the blue to avoid adding purple that much to the sceen and add to the intensity that we already have
				float r = 0.5 * ubo.wMultiStrength * length(rayResultNoReflection(rayO, normalize(rayD + ubo.wMultiSamplingOffset*ubo.camera.wDir), reflectionStrength, reflectionFallOff, false)); //ana
				float b = 0.5 * ubo.wMultiStrength * length(rayResultNoReflection(rayO, normalize(rayD - ubo.wMultiSamplingOffset*ubo.camera.wDir), reflectionStrength, reflectionFallOff, false)); //kata
				finalColor = 
				ubo.blue*rayResult(rayO, rayD, reflectionStrength, reflectionFallOff, true)+// * vec3(ubo.red,ubo.green,ubo.blue)+ //main
				ubo.wMultiStrength * vec3(r - min(r,b), 0, b - min(r,b)); 

			}
		}
	}
	
	
//	//additional samples
//	vec3 additionalColor1 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1+deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov 
//	));
//
//	vec3 additionalColor2 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1+deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));
//
//	vec3 additionalColor3 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1-deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));
//
//	vec3 additionalColor4 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1-deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));

//	vec3 additionalColor5 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1-deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1-deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));
//
//	vec3 additionalColor6 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1+deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1+deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));
//
//	vec3 additionalColor7 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1-deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1+deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));
//
//	vec3 additionalColor8 = rayResult(rayO,normalize(
//		ubo.camera.zLookDir + 
//		(1+deviationStrength)*ubo.aspectRatio*ubo.camera.xHorizontalSubRetina*(2.0*uv.x-1)/ubo.camera.fov +
//		(1-deviationStrength)*ubo.camera.yVerticalSubRetina*(2.0*uv.y-1)/ubo.camera.fov
//	));

//	//sample combination
//	finalColor = (finalColor + additionalColor1 + additionalColor2 + additionalColor3 + additionalColor4)/5;
//	//+ additionalColor5 + additionalColor6 + additionalColor7 + additionalColor8)/9;
//
	if(ubo.playerSucces == 0) imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
	else{
	if(!ubo.playerAlive) imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), (10+ubo.playerSucces)*0.1*vec4(length(finalColor),length(finalColor),length(finalColor), 0.0) -ubo.playerSucces*0.1*vec4(length(finalColor),finalColor.y*0.1,finalColor.z*0.1,0.0));
	else imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), (1+ubo.playerSucces*0.1*3) * vec4(finalColor, 0.0));
	} 
	//else imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(length(finalColor), 0.0, 0.0, 0.0));
	if(debugTest) imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0,0.0,1.0,0.0));

	
	//imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), texture(texSampler, 4*vec2(uv.x * ubo.aspectRatio,1 - uv.y)));
}

